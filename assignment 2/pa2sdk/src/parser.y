%{

#include <stdio.h>
#include <string.h>
#include "parser.h"

// Defined in the C file generated by flex. We can't include lexer.h because
// that'd cause a circular dependency (we need the header generated by bison to
// generate the lexer.h header).
extern int yylex(void);
static void yyerror(const char*);

%}

// These get stuck in a token enum in the header bison generates (parser.h),
// which we can then include in our lexer spec.
%token VAR TYPE FUNCTION
      FOR TO WHILE IF ELSE RETURN
      NIL TRUE FALSE
      INT BOOL
      ID STR NUM
      UNKNOWN
      EVAL

// These associate tokens with string lits like "<=" so we can use them in our
// grammar.
%token LT_EQ "<="
%token GT_EQ ">="
%token EQ "=="
%token NOT_EQ "!="

// The type of yylval.
%union {
      int val;
      int bool_val;
};

%type <val> NUM exp bool_exp num_exp

%left '|'
%left '&'
%left GR_EQ NOT_EQ
%left '>' '<' LT_EQ GT_EQ
%left '+' '-'
%left '*' '/' '%'
%left UPLUS UMINUS '!'
// The top-level rule.
%start program

%%

// A Liger program is either a list of declarations or it's an "extended Liger"
// program -- an EVAL token followed by a Liger expression.
program: 
      decls
      | EVAL '(' exp ')' ';'      

decls:
     VAR ID ':' NUM ';' 


//uminus uplus
exp: 
     num_exp     {yylval.val = $1;}
     |bool_exp   {yylval.bool_val = $1;}
     
num_exp:
     num_exp '+' num_exp     {$$ = $1 + $3;}
     |num_exp '-' num_exp    {$$ = $1 - $3;}
     |num_exp '*' num_exp    {$$ = $1 * $3;}
     |num_exp '/' num_exp    {$$ = $1 / $3;}
     |num_exp '%' num_exp    {$$ = $1 % $3;}
     |NUM                    {$$ = yylval.val;}
     |ID                     
     |'(' exp ')'            {$$ = $2;}

bool_exp:
     num_exp LT_EQ num_exp   {$$ = $1 <= $3 ? TRUE : FALSE ;}
     |num_exp GT_EQ num_exp  {$$ = $1 >= $3 ? TRUE : FALSE ;}
     |num_exp EQ num_exp     {$$ = $1 == $3 ? TRUE : FALSE ;}
     |num_exp NOT_EQ num_exp {$$ = $1 != $3 ? TRUE : FALSE ;}
     |num_exp '>' num_exp    {$$ = $1 > $3 ? TRUE : FALSE ;}
     |num_exp '<' num_exp    {$$ = $1 < $3 ? TRUE : FALSE ;}
     |bool_exp '&' bool_exp  {$$ = ($1 == TRUE) && ($3 == TRUE) ? TRUE : FALSE ;}
     |bool_exp '|' bool_exp  {$$ = ($1 == TRUE) || ($3 == TRUE) ? TRUE : FALSE ;}




%%


void yyerror(const char* p) {
      fprintf(stderr, "%s\n", p);
}

