%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "llstruct.h"
#include "parser.h"
//#define YYERROR_VERBOSE

// Defined in the C file generated by flex. We can't include lexer.h because
// that'd cause a circular dependency (we need the header generated by bison to
// generate the lexer.h header)


extern int yylex(void);
static void yyerror( int *returnval, int *type, int *mode, functionList **list, const char* p);
extern char* undef;

void setReturn(int *type, int *returnval, int value, int localType)
{
  if(localType > *type)
    *type = localType;
  *returnval = value;
}

void defineFunction(functionList **list, char *name, int arity )
{

  //if function list is empty
  if(*list == NULL)
  {
    *list = malloc(sizeof(functionList));
    (*list)->name = strdup(name);
    (*list)->arity = arity;
    (*list)->defined = 0;
    (*list)->arityMatch = 0;
    (*list)->calls = 0;
    (*list)->next = NULL;

  }
  //if function list exists
  else
  {
    //look for function deff
    functionList **curr = list;
    while(*curr!=NULL)
    {
      if(strcmp((*curr)->name,name)==0)
      {
        //do nothing
      }
      //add to end of list
      else if((*curr)->next == NULL)
      {
        (*curr)->next = malloc(sizeof(functionList));
        (*curr)=(*curr)->next;
        (*curr)->name=strdup(name);
        (*curr)->arity = arity;
        (*curr)->arityMatch = 0;
        (*curr)->defined = 0;
        (*curr)->calls = 0;
        (*curr)->next = NULL;
      }
      (*curr) = (*curr)->next; 
    }


  }
  
}

void functionCallCheck(functionList **list, char* name, int arity)
{
  //find function
  //if function list is empty
  if(*list == NULL)
  {

    *list = malloc(sizeof(functionList));
    (*list)->name = strdup(name);
    (*list)->arity = arity;
    (*list)->arityMatch = 0;
    (*list)->defined = 1;
    (*list)->calls = 1;
    (*list)->next = NULL;

  }
  //if function list exists
  else
  {
    //look for function
    functionList **curr = list;
    while(*curr!=NULL)
    {
      //if onlist
      if(strcmp((*curr)->name,name)==0)
      {
        (*curr)->calls++;
        (*curr)->defined = 0;
        if(arity!=(*curr)->arity)
        {
          (*curr)->arity = 1;
        }
      }
      //add to end of list if undefined
      else if((*curr)->next == NULL)
      {
        (*curr)->next = malloc(sizeof(functionList));
        (*curr)=(*curr)->next;
        (*curr)->name=strdup(name);
        (*curr)->arity = arity;
        (*curr)->arityMatch = 0;
        (*curr)->defined = 1;
        (*curr)->calls = 1;
        (*curr)->next = NULL;
      }
      *curr = (*curr)->next; 
    }

  }

}

%}
// These get stuck in a token enum in the header bison generates (parser.h),
// which we can then include in our lexer spec.
%token VAR TYPE FUNCTION
      FOR TO WHILE IF ELSE RETURN
      NIL TRUE FALSE
      INT BOOL
      ID STR NUM
      UNKNOWN
      EVAL

// These associate tokens with string lits like "<=" so we can use them in our
// grammar.
%token LT_EQ "<="
%token GT_EQ ">="
%token EQ "=="
%token NOT_EQ "!="

//values sent to yyparse() they are pointers so we can change them later to returnvalues from yyparse()
%parse-param {int *returnval} {int *type} {int *mode} {functionList **list}

// The type of yylval.
%union {
      int val;
      char *strVal;
};



//Type
%type <val> NUM INT exp NIL STR TRUE FALSE funcArgList1 funcArgList paramList paramList1
%type <strVal> ID 

%left '|'
%left '&'
%left EQ NOT_EQ
%left '>' '<' LT_EQ GT_EQ
%left '+' '-'
%left '*' '/' '%'
%left UPLUS UMINUS '!'
// The top-level rule.
%start program

%%

// A Liger program is either a list of declarations or it's an "extended Liger"
// program -- an EVAL token followed by a Liger expression.
program: 
      decls {*mode = 1;}
      | EVAL '(' exp ')' ';'

//Declarations
decls:
      decls1
      |

decls1:
      decls1 globalDec
      |globalDec

globalDec:
       VAR argDec decEnd ';'
       |TYPE argDec decEnd';'
       |func 



func:
      FUNCTION ID '(' funcArgList ')' returnType '{'  localDecls statementList '}' { defineFunction(list,$2,$4);} 

returnType:
      ':' type 
      |

statement:
      exp ';'
      |RETURN returning ';' 
      |statementAssignment ';'
      |IF '(' exp ')' '{' statementList '}' elseChunk
      |WHILE '(' exp ')' '{' statementList '}'
      |FOR '(' assignment TO exp ')' '{' statementList '}'

statementAssignment:
      leftAssignment '=' exp

leftAssignment:
      ID
      |structFieldLookUp
      |arraySubscript

arraySubscript:
      lArraySub '[' exp ']'

lArraySub:
      ID
      |commaSepArray
      |callingFunc
      |arraySubscript
      |structFieldLookUp

commaSepArray:
      '[' paramList ']' 

elseChunk:
      ELSE '{' statementList '}'
      |

returning:
      '(' exp ')' 
      |      

statementList:
      statementList1
      |

statementList1:
      statement
      |statementList1 statement 

argDec:
      ID ':' type


structFieldLookUp:
      lStructLookUp '.' ID

lStructLookUp:
      callingFunc
      |structureLiteral
      |arraySubscript
      |structFieldLookUp
      |ID

funcArgList:
      funcArgList1
      |                        {$$ = $$;}

funcArgList1:
      argDec                   {$$ = 1;}
      |funcArgList1 ',' argDec {$$ = $1 + 1;}

type:
      INT
      |BOOL
      |'[' type ']'
      |ID
      |structureType
      //fill in more possible stuct

callingFunc:
      ID '(' paramList ')' {functionCallCheck(list,$1,$3);}

paramList:
      paramList1
      |                   {$$ = $$;}

paramList1:
      exp                 {$$ = 1;}
      |paramList1 ',' exp {$$ = $1 + 1;}


localDecls:
      localDecls1
      |

localDecls1:
      localDec
      |localDecls1 localDec

localDec:
      VAR ID ':' type decEnd';'

decEnd:
      '=' exp
      |

assignment:
      ID '=' exp

assignList:
      assignList1
      |

assignList1:
      assignment
      |assignList1 ',' assignment

structureType:
      '{' funcArgList '}'

structureLiteral:
      '{' assignList '}'

exp: 
     INT
     |ID                  {$$ = 0;}
     |NUM                 {$$ = $1;}
     |NIL
     |STR
     |TRUE                {$$ = TRUE;}
     |FALSE               {$$ = FALSE;}
     |callingFunc         {$$=0; setReturn(type,returnval,0,2);}
     |structureLiteral    {$$=0; setReturn(type,returnval,0,2);}
     |structFieldLookUp   {$$=0; setReturn(type,returnval,0,2);}
     |arraySubscript      {$$=0; setReturn(type,returnval,0,2);}
     |commaSepArray       {$$=0; setReturn(type,returnval,0,2);}
     |'(' exp ')'         {$$ = $2;}
     |'+' exp %prec UPLUS {$$ = $2;}
     |'-' exp %prec UMINUS{$$ = (0-$2);}
     |'!' exp             {int val = $2; $$ = val == TRUE? FALSE : TRUE; setReturn(type,returnval,val,1);}
     |exp '+' exp         {int val = $1 + $3; $$ = val; setReturn(type,returnval,val,0);}
     |exp '-' exp         {int val = $1 - $3; $$ = val; setReturn(type,returnval,val,0);}
     |exp '*' exp         {int val = $1 * $3; $$ = val; setReturn(type,returnval,val,0);}
     |exp '/' exp         {int val = 0; if($3==0){setReturn(type,returnval,val,2);}else{val = $1 / $3; $$ = val; setReturn(type,returnval,val,0);}}
     |exp '%' exp         {int val = $1 % $3; $$ = val; setReturn(type,returnval,val,0);}
     |exp LT_EQ exp       {int val = ($1 <= $3 ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp GT_EQ exp       {int val = ($1 >= $3 ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp EQ exp          {int val = ($1 == $3 ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp NOT_EQ exp      {int val = ($1 != $3 ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp '>' exp         {int val = ($1 > $3 ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp '<' exp         {int val = ($1 < $3 ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp '&' exp         {int val = (($1==TRUE)&&($3==TRUE) ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     |exp '|' exp         {int val = (($1==TRUE) || ($3==TRUE) ? TRUE : FALSE); $$ = val; setReturn(type,returnval,val,1);}
     
%%


void yyerror( int *returnval, int *type, int *mode, functionList **list, const char* p) {
      fprintf(stderr, "%s\n", p);
}

