%{

#include <stdio.h>
#include <string.h>
#include "parser.h"

// Defined in the C file generated by flex. We can't include lexer.h because
// that'd cause a circular dependency (we need the header generated by bison to
// generate the lexer.h header).
extern int yylex(void);
static void yyerror( int *returnval, int *type, const char* p);
extern char* undef;

void setResult(int set, int *curr)
{
   if(set > *curr)
   {
      *curr = set;
   }
   return;
}
%}

// These get stuck in a token enum in the header bison generates (parser.h),
// which we can then include in our lexer spec.
%token VAR TYPE FUNCTION
      FOR TO WHILE IF ELSE RETURN
      NIL TRUE FALSE
      INT BOOL
      ID STR NUM
      UNKNOWN
      EVAL

// These associate tokens with string lits like "<=" so we can use them in our
// grammar.
%token LT_EQ "<="
%token GT_EQ ">="
%token EQ "=="
%token NOT_EQ "!="

//values sent to yyparse() they are pointers so we can change them later to returnvalues from yyparse()
%parse-param {int *returnval} {int *type}

// The type of yylval.
%union {
      int val;
};



//Type
%type <val> NUM INT

%left '|'
%left '&'
%left GR_EQ NOT_EQ
%left '>' '<' LT_EQ GT_EQ
%left '+' '-'
%left '*' '/' '%'
%left UPLUS UMINUS '!'
// The top-level rule.
%start program

%%

// A Liger program is either a list of declarations or it's an "extended Liger"
// program -- an EVAL token followed by a Liger expression.
program: 
      decls
      | EVAL '(' exp ')' ';'

decls:
       VAR ID ':' exp ';'
       |TYPE ID ':' exp ';'
       
decls1:
        ID ':' INT decls2
decls2:
        ',' decls1
        |


//uminus uplus
exp: 
     lValue
     |INT
     |ID
     |NUM
     |NIL
     |STR
     |FUNCTION ID '(' arglist ')'
     |exp biOp exp  
     |unOp exp
     |ID '{' fieldExpList '}'
     |'[' exp ']'
     |'[' arglist ']'
     |'{' decls1 '}'
     |'{' fieldExpList '}'
     |'(' expList ')'
     |lValue '=' exp
     |IF '(' exp ')' '{' exp '}' 
     |IF '(' exp ')' '{' exp '}' ELSE '{' exp '}'
     |WHILE '(' exp ')' '{' exp '}'
     |FOR '(' exp TO exp')' '{' exp '}'

lValue:
      ID
      |lValue '.' ID
      |lValue '[' exp ']'

arglist:
      exp arglist1
      |
arglist1:
      ',' exp arglist1
      |

biOp:
      '+'
      |'-'
      |'*'
      |'/'
      |'%'
      |LT_EQ
      |GT_EQ
      |EQ
      |NOT_EQ
      |'>'
      |'<'
      |'&'
      |'|'

unOp:
      '!'
      |'-'
      |'+'

fieldExpList:
      ID '=' exp fieldExpList1
      |

fieldExpList1:
      ',' ID '=' exp fieldExpList1
      |

expList:
      exp expList1
      |

expList1:
      ';' expList1
      |

     
%%


void yyerror( int *returnval, int *type, const char* p) {
      fprintf(stderr, "%s\n", p);
}

int evaluate(int left, int right, char op)
{
  
}

